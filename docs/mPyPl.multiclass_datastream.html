<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module mPyPl.multiclass_datastream</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="mPyPl.html"><font color="#ffffff">mPyPl</font></a>.multiclass_datastream</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cwinapp%5Cminiconda3%5Clib%5Csite-packages%5Cmpypl%5Cmulticlass_datastream.py">c:\winapp\miniconda3\lib\site-packages\mpypl\multiclass_datastream.py</a></font></td></tr></table>
    <p><tt>This&nbsp;module&nbsp;expects&nbsp;the&nbsp;following&nbsp;directory&nbsp;structure&nbsp;of&nbsp;files:<br>
```<br>
&nbsp;&nbsp;&nbsp;base_dir<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file1.ext<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file2.ext<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_1.ext<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split.txt&nbsp;-&nbsp;splitter&nbsp;file&nbsp;to&nbsp;define&nbsp;train-test&nbsp;split&nbsp;of&nbsp;files&nbsp;(contains&nbsp;filenames)</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="builtins.html">builtins</a><br>
<a href="cv2.cv2.html">cv2.cv2</a><br>
<a href="enum.html">enum</a><br>
<a href="functools.html">functools</a><br>
</td><td width="25%" valign=top><a href="itertools.html">itertools</a><br>
<a href="json.html">json</a><br>
<a href="math.html">math</a><br>
<a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top><a href="os.html">os</a><br>
<a href="pickle.html">pickle</a><br>
<a href="random.html">random</a><br>
<a href="sys.html">sys</a><br>
</td><td width="25%" valign=top><a href="types.html">types</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="enum.html#Enum">enum.Enum</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="mPyPl.multiclass_datastream.html#SplitType">SplitType</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SplitType">class <strong>SplitType</strong></a>(<a href="enum.html#Enum">enum.Enum</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#SplitType">SplitType</a>(value,&nbsp;names=None,&nbsp;*,&nbsp;module=None,&nbsp;qualname=None,&nbsp;type=None,&nbsp;start=1)<br>
&nbsp;<br>
An&nbsp;enumeration.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="mPyPl.multiclass_datastream.html#SplitType">SplitType</a></dd>
<dd><a href="enum.html#Enum">enum.Enum</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>Test</strong> = &lt;SplitType.Test: 3&gt;</dl>

<dl><dt><strong>Train</strong> = &lt;SplitType.Train: 2&gt;</dl>

<dl><dt><strong>Unknown</strong> = &lt;SplitType.Unknown: 1&gt;</dl>

<dl><dt><strong>Valiadation</strong> = &lt;SplitType.Valiadation: 4&gt;</dl>

<hr>
Data descriptors inherited from <a href="enum.html#Enum">enum.Enum</a>:<br>
<dl><dt><strong>name</strong></dt>
<dd><tt>The&nbsp;name&nbsp;of&nbsp;the&nbsp;Enum&nbsp;member.</tt></dd>
</dl>
<dl><dt><strong>value</strong></dt>
<dd><tt>The&nbsp;value&nbsp;of&nbsp;the&nbsp;Enum&nbsp;member.</tt></dd>
</dl>
<hr>
Data descriptors inherited from <a href="enum.html#EnumMeta">enum.EnumMeta</a>:<br>
<dl><dt><strong>__members__</strong></dt>
<dd><tt>Returns&nbsp;a&nbsp;mapping&nbsp;of&nbsp;member&nbsp;name-&gt;value.<br>
&nbsp;<br>
This&nbsp;mapping&nbsp;lists&nbsp;all&nbsp;enum&nbsp;members,&nbsp;including&nbsp;aliases.&nbsp;Note&nbsp;that&nbsp;this<br>
is&nbsp;a&nbsp;read-only&nbsp;view&nbsp;of&nbsp;the&nbsp;internal&nbsp;mapping.</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-get_classes"><strong>get_classes</strong></a>(data_dir, include_hidden=False)</dt><dd><tt>Automatically&nbsp;generate&nbsp;class&nbsp;description&nbsp;dictionary&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;get_datastream.&nbsp;It&nbsp;assumes&nbsp;standard&nbsp;directory&nbsp;structure.<br>
:param&nbsp;data_dir:&nbsp;Base&nbsp;data&nbsp;directory<br>
:return:&nbsp;Dictionary&nbsp;of&nbsp;the&nbsp;form&nbsp;{&nbsp;'dir0'&nbsp;:&nbsp;0,&nbsp;'dir1'&nbsp;:&nbsp;1,&nbsp;...&nbsp;}</tt></dd></dl>
 <dl><dt><a name="-get_datastream"><strong>get_datastream</strong></a>(data_dir, ext=None, classes=None, split_filename=None)</dt><dd><tt>Get&nbsp;a&nbsp;stream&nbsp;of&nbsp;objects&nbsp;for&nbsp;a&nbsp;number&nbsp;of&nbsp;classes&nbsp;specified&nbsp;as&nbsp;dict&nbsp;of&nbsp;the&nbsp;form&nbsp;{&nbsp;'dir0'&nbsp;:&nbsp;0,&nbsp;'dir1'&nbsp;:&nbsp;1,&nbsp;...&nbsp;}<br>
Returns&nbsp;stream&nbsp;of&nbsp;dictionaries&nbsp;of&nbsp;the&nbsp;form&nbsp;{&nbsp;class_id:&nbsp;...&nbsp;,&nbsp;class_name:&nbsp;...,&nbsp;filename:&nbsp;...&nbsp;}<br>
`classes`&nbsp;is&nbsp;the&nbsp;dictionary&nbsp;of&nbsp;the&nbsp;form&nbsp;{&nbsp;'class_name'&nbsp;:&nbsp;class_id,&nbsp;...&nbsp;}</tt></dd></dl>
 <dl><dt><a name="-isdir"><strong>isdir</strong></a> = _isdir(path, /)</dt><dd><tt>Return&nbsp;true&nbsp;if&nbsp;the&nbsp;pathname&nbsp;refers&nbsp;to&nbsp;an&nbsp;existing&nbsp;directory.</tt></dd></dl>
 <dl><dt><a name="-make_split"><strong>make_split</strong></a>(datastream, split_value=0.2)</dt><dd><tt>Split&nbsp;datastream&nbsp;into&nbsp;train-validation-test&nbsp;or&nbsp;train-test&nbsp;sets&nbsp;in&nbsp;a&nbsp;stratified&nbsp;manner.<br>
:param&nbsp;datastream:&nbsp;datastream&nbsp;to&nbsp;use<br>
:param&nbsp;split_value:&nbsp;if&nbsp;float&nbsp;-&nbsp;indicates&nbsp;fraction&nbsp;of&nbsp;data&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;test&nbsp;dataset.&nbsp;If&nbsp;typle&nbsp;`(val,test)`&nbsp;-&nbsp;indicates<br>
fractions&nbsp;used&nbsp;for&nbsp;validation&nbsp;and&nbsp;test&nbsp;split&nbsp;accordingly.&nbsp;Detaults&nbsp;to&nbsp;0.2.<br>
:return:&nbsp;Dictionary&nbsp;with&nbsp;objects&nbsp;split&nbsp;between&nbsp;given&nbsp;datasets.&nbsp;If&nbsp;datastream&nbsp;contains&nbsp;`filename`&nbsp;field,&nbsp;filenames&nbsp;are&nbsp;returned,<br>
otherwise&nbsp;the&nbsp;actual&nbsp;objects.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Pipe functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-add"><strong>add</strong></a>(x)</dt></dl>
 <dl><dt><a name="-aggregate"><strong>aggregate</strong></a>(iterable, function, **kwargs)</dt></dl>
 <dl><dt><a name="-all"><strong>all</strong></a>(iterable, pred)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;ALL&nbsp;elements&nbsp;in&nbsp;the&nbsp;given&nbsp;iterable&nbsp;are&nbsp;true&nbsp;for&nbsp;the<br>
given&nbsp;pred&nbsp;function</tt></dd></dl>
 <dl><dt><a name="-any"><strong>any</strong></a>(iterable, pred)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;ANY&nbsp;element&nbsp;in&nbsp;the&nbsp;given&nbsp;iterable&nbsp;is&nbsp;True&nbsp;for&nbsp;the<br>
given&nbsp;pred&nbsp;function</tt></dd></dl>
 <dl><dt><a name="-apply"><strong>apply</strong></a>(datastream, src_field, dst_field, func, eval_strategy=None)</dt><dd><tt>Applies&nbsp;a&nbsp;function&nbsp;to&nbsp;the&nbsp;specified&nbsp;field&nbsp;of&nbsp;the&nbsp;stream&nbsp;and&nbsp;stores&nbsp;the&nbsp;result&nbsp;in&nbsp;the&nbsp;specified&nbsp;field.&nbsp;Sample&nbsp;usage:<br>
`[1,2,3]&nbsp;|&nbsp;as_field('f1')&nbsp;|&nbsp;apply('f1','f2',lambda&nbsp;x:&nbsp;x*x)&nbsp;|&nbsp;select_field('f2')&nbsp;|&nbsp;as_list`<br>
If&nbsp;`dst_field`&nbsp;is&nbsp;`None`,&nbsp;function&nbsp;is&nbsp;just&nbsp;executed&nbsp;on&nbsp;the&nbsp;source&nbsp;field(s),&nbsp;and&nbsp;result&nbsp;is&nbsp;not&nbsp;stored.<br>
This&nbsp;is&nbsp;useful&nbsp;when&nbsp;there&nbsp;are&nbsp;side&nbsp;effects.</tt></dd></dl>
 <dl><dt><a name="-apply_batch"><strong>apply_batch</strong></a>(datastream, src_field, dst_field, func, batch_size=32)</dt><dd><tt>Apply&nbsp;function&nbsp;to&nbsp;the&nbsp;field&nbsp;in&nbsp;batches.&nbsp;`batch_size`&nbsp;elements&nbsp;are&nbsp;accumulated&nbsp;into&nbsp;the&nbsp;list,&nbsp;and&nbsp;`func`&nbsp;is&nbsp;called<br>
with&nbsp;this&nbsp;parameter.</tt></dd></dl>
 <dl><dt><a name="-apply_npy"><strong>apply_npy</strong></a>(datastream, src_field, dst_field, func, file_ext=None)</dt><dd><tt>A&nbsp;caching&nbsp;apply&nbsp;that&nbsp;computes&nbsp;some&nbsp;function&nbsp;returning&nbsp;numpy&nbsp;array,&nbsp;and&nbsp;stores&nbsp;the&nbsp;result&nbsp;on&nbsp;disk<br>
:param&nbsp;datastream:&nbsp;datastream<br>
:param&nbsp;src_field:&nbsp;source&nbsp;field&nbsp;to&nbsp;use&nbsp;as&nbsp;argument.&nbsp;Can&nbsp;be&nbsp;one&nbsp;field&nbsp;or&nbsp;list&nbsp;of&nbsp;fields<br>
:param&nbsp;dst_field:&nbsp;destination&nbsp;field&nbsp;name<br>
:param&nbsp;func:&nbsp;function&nbsp;to&nbsp;apply,&nbsp;accepts&nbsp;either&nbsp;one&nbsp;argument&nbsp;or&nbsp;list&nbsp;of&nbsp;arguments<br>
:param&nbsp;file_ext:&nbsp;file&nbsp;extension&nbsp;to&nbsp;use&nbsp;(dst_field+'.npy')&nbsp;by&nbsp;default<br>
:return:&nbsp;processed&nbsp;file&nbsp;stream</tt></dd></dl>
 <dl><dt><a name="-apply_nx"><strong>apply_nx</strong></a>(datastream, src_field, dst_field, func, eval_strategy=None, print_exceptions=False)</dt><dd><tt>Same&nbsp;as&nbsp;`apply`,&nbsp;but&nbsp;ignores&nbsp;exceptions&nbsp;by&nbsp;just&nbsp;skipping&nbsp;elements&nbsp;with&nbsp;errors.</tt></dd></dl>
 <dl><dt><a name="-as_dict"><strong>as_dict</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-as_field"><strong>as_field</strong></a>(datastream, field_name)</dt><dd><tt>Convert&nbsp;stream&nbsp;of&nbsp;any&nbsp;objects&nbsp;into&nbsp;proper&nbsp;datastream&nbsp;of&nbsp;`mdict`'s,&nbsp;with&nbsp;one&nbsp;named&nbsp;field</tt></dd></dl>
 <dl><dt><a name="-as_list"><strong>as_list</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-as_npy"><strong>as_npy</strong></a>(l)</dt><dd><tt>Convert&nbsp;the&nbsp;sequence&nbsp;into&nbsp;numpy&nbsp;array.&nbsp;Use&nbsp;as&nbsp;`seq&nbsp;|&nbsp;as_npy`<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator&nbsp;(finite)<br>
:return:&nbsp;numpy&nbsp;array&nbsp;created&nbsp;from&nbsp;the&nbsp;generator</tt></dd></dl>
 <dl><dt><a name="-as_set"><strong>as_set</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-as_tuple"><strong>as_tuple</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-average"><strong>average</strong></a>(iterable)</dt><dd><tt>Build&nbsp;the&nbsp;average&nbsp;for&nbsp;the&nbsp;given&nbsp;iterable,&nbsp;starting&nbsp;with&nbsp;0.0&nbsp;as&nbsp;seed<br>
Will&nbsp;try&nbsp;a&nbsp;division&nbsp;by&nbsp;0&nbsp;if&nbsp;the&nbsp;iterable&nbsp;is&nbsp;empty...</tt></dd></dl>
 <dl><dt><a name="-batch"><strong>batch</strong></a>(datastream, k, n)</dt><dd><tt>Separate&nbsp;only&nbsp;part&nbsp;of&nbsp;the&nbsp;stream&nbsp;for&nbsp;parallel&nbsp;batch&nbsp;processing.&nbsp;If&nbsp;you&nbsp;have&nbsp;`n`&nbsp;nodes,&nbsp;pass&nbsp;number&nbsp;of&nbsp;current&nbsp;node<br>
as&nbsp;`k`&nbsp;(from&nbsp;0&nbsp;to&nbsp;n-1),&nbsp;and&nbsp;it&nbsp;will&nbsp;pass&nbsp;only&nbsp;part&nbsp;of&nbsp;the&nbsp;stream&nbsp;to&nbsp;be&nbsp;processed&nbsp;by&nbsp;that&nbsp;node.&nbsp;Namely,&nbsp;for&nbsp;i-th<br>
element&nbsp;of&nbsp;the&nbsp;stream,&nbsp;it&nbsp;is&nbsp;passed&nbsp;through&nbsp;if&nbsp;i%n==k<br>
:param&nbsp;datastream:&nbsp;datastream<br>
:param&nbsp;k:&nbsp;number&nbsp;of&nbsp;current&nbsp;node&nbsp;in&nbsp;cluster<br>
:param&nbsp;n:&nbsp;total&nbsp;number&nbsp;of&nbsp;nodes<br>
:return:&nbsp;resulting&nbsp;datastream&nbsp;which&nbsp;is&nbsp;subset&nbsp;of&nbsp;the&nbsp;original&nbsp;one</tt></dd></dl>
 <dl><dt><a name="-chain"><strong>chain</strong></a>(iterable)</dt></dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>chain_with</strong> = <a name="chain_with">class chain</a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>chain(*iterables)&nbsp;--&gt;&nbsp;chain&nbsp;object<br>
&nbsp;<br>
Return&nbsp;a&nbsp;chain&nbsp;object&nbsp;whose&nbsp;.<a href="#chain_with-__next__">__next__</a>()&nbsp;method&nbsp;returns&nbsp;elements&nbsp;from&nbsp;the<br>
first&nbsp;iterable&nbsp;until&nbsp;it&nbsp;is&nbsp;exhausted,&nbsp;then&nbsp;elements&nbsp;from&nbsp;the&nbsp;next<br>
iterable,&nbsp;until&nbsp;all&nbsp;of&nbsp;the&nbsp;iterables&nbsp;are&nbsp;exhausted.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="chain-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="chain-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="chain-__next__"><strong>__next__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;next(self).</tt></dd></dl>

<dl><dt><a name="chain-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Return&nbsp;state&nbsp;information&nbsp;for&nbsp;pickling.</tt></dd></dl>

<dl><dt><a name="chain-__setstate__"><strong>__setstate__</strong></a>(...)</dt><dd><tt>Set&nbsp;state&nbsp;information&nbsp;for&nbsp;unpickling.</tt></dd></dl>

<hr>
Class methods defined here:<br>
<dl><dt><a name="chain-from_iterable"><strong>from_iterable</strong></a>(...)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>chain.<a href="#chain_with-from_iterable">from_iterable</a>(iterable)&nbsp;--&gt;&nbsp;chain&nbsp;object<br>
&nbsp;<br>
Alternate&nbsp;chain()&nbsp;constructor&nbsp;taking&nbsp;a&nbsp;single&nbsp;iterable&nbsp;argument<br>
that&nbsp;evaluates&nbsp;lazily.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="chain-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;object.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

</td></tr></table> <dl><dt><a name="-concat"><strong>concat</strong></a>(iterable, separator=', ')</dt></dl>
 <dl><dt><a name="-count"><strong>count</strong></a>(iterable)</dt><dd><tt>Count&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;given&nbsp;iterable,&nbsp;walking&nbsp;thrue&nbsp;it.</tt></dd></dl>
 <dl><dt><a name="-count_classes"><strong>count_classes</strong></a>(datastream, class_field_name)</dt><dd><tt>Count&nbsp;number&nbsp;of&nbsp;elements&nbsp;in&nbsp;difference&nbsp;classes.<br>
:param&nbsp;datastream:&nbsp;input&nbsp;data&nbsp;stream<br>
:param&nbsp;class_field_name:&nbsp;name&nbsp;of&nbsp;the&nbsp;field&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;counting<br>
:return:&nbsp;mdict&nbsp;with&nbsp;classes&nbsp;and&nbsp;their&nbsp;values</tt></dd></dl>
 <dl><dt><a name="-datasplit"><strong>datasplit</strong></a>(datastream, split_param=None, split_value=0.2)</dt><dd><tt>Very&nbsp;flexible&nbsp;function&nbsp;for&nbsp;splitting&nbsp;the&nbsp;dataset&nbsp;into&nbsp;train-test&nbsp;or&nbsp;train-test-validation&nbsp;dataset.&nbsp;If&nbsp;datastream<br>
contains&nbsp;field&nbsp;`filename`&nbsp;-&nbsp;all&nbsp;splitting&nbsp;is&nbsp;performed&nbsp;based&nbsp;on&nbsp;the&nbsp;filename&nbsp;(directories&nbsp;are&nbsp;ommited&nbsp;to&nbsp;simplify<br>
moving&nbsp;data&nbsp;and&nbsp;split&nbsp;file&nbsp;onto&nbsp;different&nbsp;path).&nbsp;If&nbsp;not&nbsp;-&nbsp;original&nbsp;objects&nbsp;are&nbsp;used.<br>
:param&nbsp;datastream:&nbsp;datastream&nbsp;to&nbsp;split<br>
:param&nbsp;split_param:&nbsp;either&nbsp;filename&nbsp;of&nbsp;'split.txt'&nbsp;file,&nbsp;or&nbsp;dictionary&nbsp;of&nbsp;filenames.&nbsp;If&nbsp;the&nbsp;file&nbsp;does&nbsp;not&nbsp;exist&nbsp;-&nbsp;stratified&nbsp;split&nbsp;is&nbsp;performed,&nbsp;and&nbsp;file&nbsp;is&nbsp;created.&nbsp;If&nbsp;`split_param`&nbsp;is&nbsp;None,&nbsp;temporary&nbsp;split&nbsp;is&nbsp;performed.<br>
:param&nbsp;split_value:&nbsp;either&nbsp;one&nbsp;value&nbsp;(default&nbsp;is&nbsp;0.2),&nbsp;in&nbsp;which&nbsp;case&nbsp;train-test&nbsp;split&nbsp;is&nbsp;performed,&nbsp;or&nbsp;pair&nbsp;of&nbsp;`(validation,test)`&nbsp;values<br>
:return:&nbsp;datastream&nbsp;with&nbsp;additional&nbsp;field&nbsp;`split`</tt></dd></dl>
 <dl><dt><a name="-datasplit_by_pattern"><strong>datasplit_by_pattern</strong></a>(datastream, train_pattern=None, valid_pattern=None, test_pattern=None)</dt><dd><tt>Attach&nbsp;data&nbsp;split&nbsp;info&nbsp;to&nbsp;the&nbsp;stream&nbsp;according&nbsp;to&nbsp;some&nbsp;pattern&nbsp;in&nbsp;filename.<br>
:param&nbsp;datastream:&nbsp;Datastream,&nbsp;which&nbsp;should&nbsp;contain&nbsp;the&nbsp;field&nbsp;'filename',&nbsp;or&nbsp;be&nbsp;string&nbsp;stream<br>
:param&nbsp;train_pattern:&nbsp;Train&nbsp;pattern&nbsp;to&nbsp;use.&nbsp;If&nbsp;None,&nbsp;all&nbsp;are&nbsp;considered&nbsp;Train&nbsp;by&nbsp;default<br>
:param&nbsp;valid_pattern:&nbsp;Validation&nbsp;pattern&nbsp;to&nbsp;use.&nbsp;If&nbsp;None,&nbsp;there&nbsp;will&nbsp;be&nbsp;no&nbsp;validation.<br>
:param&nbsp;test_pattern:&nbsp;Test&nbsp;pattern&nbsp;to&nbsp;use.&nbsp;If&nbsp;None,&nbsp;there&nbsp;will&nbsp;be&nbsp;no&nbsp;validation.<br>
:return:&nbsp;Datastream&nbsp;augmented&nbsp;with&nbsp;`split`&nbsp;field</tt></dd></dl>
 <dl><dt><a name="-dedup"><strong>dedup</strong></a>(iterable)</dt><dd><tt>Only&nbsp;yield&nbsp;unique&nbsp;items.&nbsp;Use&nbsp;a&nbsp;set&nbsp;to&nbsp;keep&nbsp;track&nbsp;of&nbsp;duplicate&nbsp;data.</tt></dd></dl>
 <dl><dt><a name="-delay"><strong>delay</strong></a>(seq, field_name, delayed_field_name)</dt><dd><tt>Create&nbsp;another&nbsp;field&nbsp;`delayed_field_name`&nbsp;from&nbsp;`field_name`&nbsp;that&nbsp;is&nbsp;one&nbsp;step&nbsp;delayed<br>
:param&nbsp;seq:&nbsp;Sequence<br>
:param&nbsp;field_name:&nbsp;Original&nbsp;existing&nbsp;field&nbsp;name<br>
:param&nbsp;delayed_field_name:&nbsp;New&nbsp;field&nbsp;name&nbsp;to&nbsp;hold&nbsp;the&nbsp;delayed&nbsp;value<br>
:return:&nbsp;New&nbsp;sequence</tt></dd></dl>
 <dl><dt><a name="-delfield"><strong>delfield</strong></a>(datastream, field_name)</dt><dd><tt>Delete&nbsp;specified&nbsp;field&nbsp;`field_name`&nbsp;from&nbsp;the&nbsp;stream.&nbsp;This&nbsp;is&nbsp;typically&nbsp;done&nbsp;in&nbsp;order&nbsp;to&nbsp;save&nbsp;memory.</tt></dd></dl>
 <dl><dt><a name="-dict_group_by"><strong>dict_group_by</strong></a>(datasteam, field_name)</dt><dd><tt>Group&nbsp;all&nbsp;the&nbsp;records&nbsp;by&nbsp;the&nbsp;given&nbsp;field&nbsp;name.&nbsp;Returns&nbsp;dictionary&nbsp;that&nbsp;for&nbsp;each&nbsp;value&nbsp;of&nbsp;the&nbsp;field&nbsp;contains&nbsp;lists<br>
of&nbsp;corresponding&nbsp;`mdict`-s.&nbsp;**Important**:&nbsp;This&nbsp;operation&nbsp;loads&nbsp;whole&nbsp;dataset&nbsp;into&nbsp;memory,&nbsp;so&nbsp;for&nbsp;big&nbsp;data&nbsp;fields<br>
it&nbsp;is&nbsp;better&nbsp;to&nbsp;use&nbsp;lazy&nbsp;evaluation.<br>
:param&nbsp;datasteam:&nbsp;input&nbsp;datastream<br>
:param&nbsp;field_name:&nbsp;field&nbsp;name&nbsp;to&nbsp;use<br>
:return:&nbsp;dictionary&nbsp;of&nbsp;the&nbsp;form&nbsp;`{&nbsp;'value-1'&nbsp;:&nbsp;[&nbsp;...&nbsp;],&nbsp;...}`</tt></dd></dl>
 <dl><dt><a name="-ensure_field"><strong>ensure_field</strong></a>(datastream, field_name)</dt><dd><tt>Ensure&nbsp;that&nbsp;the&nbsp;field&nbsp;with&nbsp;the&nbsp;given&nbsp;name&nbsp;exists.&nbsp;All&nbsp;records&nbsp;non&nbsp;containing&nbsp;that&nbsp;field&nbsp;are&nbsp;skipped.<br>
:param&nbsp;datastream:&nbsp;input&nbsp;datastream<br>
:param&nbsp;field_name:&nbsp;field&nbsp;name<br>
:return:&nbsp;output&nbsp;datastream</tt></dd></dl>
 <dl><dt><a name="-execute"><strong>execute</strong></a>(l)</dt><dd><tt>Runs&nbsp;all&nbsp;elements&nbsp;of&nbsp;the&nbsp;pipeline,&nbsp;ignoring&nbsp;the&nbsp;result<br>
The&nbsp;same&nbsp;as&nbsp;_&nbsp;=&nbsp;pipe&nbsp;|&nbsp;as_list<br>
:param&nbsp;l:&nbsp;Pipeline&nbsp;to&nbsp;execute</tt></dd></dl>
 <dl><dt><a name="-fapply"><strong>fapply</strong></a>(datastream, dst_field, func, eval_strategy=None)</dt><dd><tt>Applies&nbsp;a&nbsp;function&nbsp;to&nbsp;the&nbsp;whole&nbsp;dictionary&nbsp;and&nbsp;stores&nbsp;the&nbsp;result&nbsp;in&nbsp;the&nbsp;specified&nbsp;field.<br>
This&nbsp;function&nbsp;should&nbsp;rarely&nbsp;be&nbsp;used&nbsp;externaly,&nbsp;choice&nbsp;should&nbsp;be&nbsp;made&nbsp;in&nbsp;favour&nbsp;of&nbsp;`apply`,&nbsp;because&nbsp;it&nbsp;does&nbsp;not&nbsp;involve<br>
operating&nbsp;on&nbsp;internals&nbsp;of&nbsp;`dict`</tt></dd></dl>
 <dl><dt><a name="-fenumerate"><strong>fenumerate</strong></a>(l, field_name, start=0)</dt><dd><tt>Add&nbsp;extra&nbsp;field&nbsp;to&nbsp;datastream&nbsp;which&nbsp;contains&nbsp;number&nbsp;of&nbsp;record<br>
:param&nbsp;l:<br>
:param&nbsp;field_name:<br>
:return:</tt></dd></dl>
 <dl><dt><a name="-filter"><strong>filter</strong></a>(datastream, src_field, pred)</dt><dd><tt>Filters&nbsp;out&nbsp;fields&nbsp;that&nbsp;yield&nbsp;a&nbsp;given&nbsp;criteria.<br>
:param&nbsp;datastream:&nbsp;input&nbsp;datastream<br>
:param&nbsp;src_field:&nbsp;field&nbsp;of&nbsp;list&nbsp;of&nbsp;fields&nbsp;to&nbsp;consider<br>
:param&nbsp;pred:&nbsp;predicate&nbsp;function.&nbsp;If&nbsp;`src_field`&nbsp;is&nbsp;one&nbsp;field,&nbsp;than&nbsp;`pred`&nbsp;is&nbsp;a&nbsp;function&nbsp;of&nbsp;one&nbsp;argument&nbsp;returning&nbsp;boolean.<br>
If&nbsp;`src_field`&nbsp;is&nbsp;a&nbsp;list,&nbsp;`pred`&nbsp;takes&nbsp;tuple/list&nbsp;as&nbsp;an&nbsp;argument.<br>
:return:&nbsp;datastream&nbsp;with&nbsp;fields&nbsp;that&nbsp;yield&nbsp;predicate</tt></dd></dl>
 <dl><dt><a name="-filter_split"><strong>filter_split</strong></a>(datastream, split_type)</dt><dd><tt>Returns&nbsp;a&nbsp;datastream&nbsp;of&nbsp;the&nbsp;corresponding&nbsp;split&nbsp;type<br>
:param&nbsp;datastream:&nbsp;Input&nbsp;datastream<br>
:return:&nbsp;Tuple&nbsp;of&nbsp;the&nbsp;form&nbsp;`(train_stream,test_stream)`</tt></dd></dl>
 <dl><dt><a name="-first"><strong>first</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-fold"><strong>fold</strong></a>(l, field_name, func, init_state)</dt><dd><tt>Perform&nbsp;fold&nbsp;of&nbsp;the&nbsp;datastream,&nbsp;using&nbsp;given&nbsp;fold&nbsp;function&nbsp;`func`&nbsp;with&nbsp;initial&nbsp;state&nbsp;`init_state`<br>
:param&nbsp;l:&nbsp;datastream<br>
:param&nbsp;field_name:&nbsp;field&nbsp;name&nbsp;(or&nbsp;list&nbsp;of&nbsp;names)&nbsp;to&nbsp;use<br>
:param&nbsp;func:&nbsp;fold&nbsp;function&nbsp;that&nbsp;takes&nbsp;field(s)&nbsp;value&nbsp;and&nbsp;state&nbsp;and&nbsp;returns&nbsp;state.&nbsp;If&nbsp;field_name&nbsp;is&nbsp;None,&nbsp;func<br>
accepts&nbsp;the&nbsp;whole&nbsp;`mdict`&nbsp;as&nbsp;first&nbsp;parameter<br>
:param&nbsp;init_state:&nbsp;initial&nbsp;state<br>
:return:&nbsp;final&nbsp;state&nbsp;of&nbsp;the&nbsp;fold</tt></dd></dl>
 <dl><dt><a name="-groupby"><strong>groupby</strong></a>(iterable, keyfunc)</dt></dl>
 <dl><dt><a name="-index"><strong>index</strong></a>(iterable, value, start=0, stop=None)</dt></dl>
 <dl><dt><a name="-infshuffle"><strong>infshuffle</strong></a>(l)</dt><dd><tt>Function&nbsp;that&nbsp;turns&nbsp;sequence&nbsp;into&nbsp;infinite&nbsp;shuffled&nbsp;sequence.&nbsp;It&nbsp;loads&nbsp;it&nbsp;into&nbsp;memory&nbsp;for&nbsp;processing.<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:return:&nbsp;result&nbsp;sequence</tt></dd></dl>
 <dl><dt><a name="-inspect"><strong>inspect</strong></a>(seq, func=None, message='Inspecting mdict')</dt><dd><tt>Print&nbsp;out&nbsp;the&nbsp;info&nbsp;about&nbsp;the&nbsp;fields&nbsp;in&nbsp;a&nbsp;given&nbsp;stream<br>
:return:&nbsp;Original&nbsp;sequence</tt></dd></dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="islice">class <strong>islice</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>islice(iterable,&nbsp;stop)&nbsp;--&gt;&nbsp;islice&nbsp;object<br>
islice(iterable,&nbsp;start,&nbsp;stop[,&nbsp;step])&nbsp;--&gt;&nbsp;islice&nbsp;object<br>
&nbsp;<br>
Return&nbsp;an&nbsp;iterator&nbsp;whose&nbsp;next()&nbsp;method&nbsp;returns&nbsp;selected&nbsp;values&nbsp;from&nbsp;an<br>
iterable.&nbsp;&nbsp;If&nbsp;start&nbsp;is&nbsp;specified,&nbsp;will&nbsp;skip&nbsp;all&nbsp;preceding&nbsp;elements;<br>
otherwise,&nbsp;start&nbsp;defaults&nbsp;to&nbsp;zero.&nbsp;&nbsp;Step&nbsp;defaults&nbsp;to&nbsp;one.&nbsp;&nbsp;If<br>
specified&nbsp;as&nbsp;another&nbsp;value,&nbsp;step&nbsp;determines&nbsp;how&nbsp;many&nbsp;values&nbsp;are&nbsp;<br>
skipped&nbsp;between&nbsp;successive&nbsp;calls.&nbsp;&nbsp;Works&nbsp;like&nbsp;a&nbsp;slice()&nbsp;on&nbsp;a&nbsp;list<br>
but&nbsp;returns&nbsp;an&nbsp;iterator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="islice-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="islice-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="islice-__next__"><strong>__next__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;next(self).</tt></dd></dl>

<dl><dt><a name="islice-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Return&nbsp;state&nbsp;information&nbsp;for&nbsp;pickling.</tt></dd></dl>

<dl><dt><a name="islice-__setstate__"><strong>__setstate__</strong></a>(...)</dt><dd><tt>Set&nbsp;state&nbsp;information&nbsp;for&nbsp;unpickling.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="islice-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;object.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

</td></tr></table> <dl><dt><a name="-iter"><strong>iter</strong></a>(datastream, field_name=None, func=None)</dt><dd><tt>Execute&nbsp;function&nbsp;`func`&nbsp;on&nbsp;field&nbsp;`field_name`&nbsp;(or&nbsp;list&nbsp;of&nbsp;fields)&nbsp;of&nbsp;every&nbsp;item.<br>
If&nbsp;`field_name`&nbsp;is&nbsp;omitted&nbsp;or&nbsp;`None`,&nbsp;function&nbsp;is&nbsp;applied&nbsp;on&nbsp;the&nbsp;whole&nbsp;dictionary&nbsp;(this&nbsp;usage&nbsp;is&nbsp;not&nbsp;recommended).</tt></dd></dl>
 <dl><dt><a name="-iteri"><strong>iteri</strong></a>(datastream, field_name=None, func=None)</dt><dd><tt>Execute&nbsp;function&nbsp;`func`&nbsp;on&nbsp;field&nbsp;`field_name`&nbsp;(or&nbsp;list&nbsp;of&nbsp;fields)&nbsp;of&nbsp;every&nbsp;item.<br>
If&nbsp;`field_name`&nbsp;is&nbsp;omitted&nbsp;or&nbsp;`None`,&nbsp;function&nbsp;is&nbsp;applied&nbsp;on&nbsp;the&nbsp;whole&nbsp;dictionary&nbsp;(this&nbsp;usage&nbsp;is&nbsp;not&nbsp;recommended).<br>
Function&nbsp;receives&nbsp;number&nbsp;of&nbsp;frame&nbsp;as&nbsp;the&nbsp;first&nbsp;argument</tt></dd></dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>izip</strong> = <a name="izip">class zip</a>(<a href="builtins.html#object">object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>zip(iter1&nbsp;[,iter2&nbsp;[...]])&nbsp;--&gt;&nbsp;zip&nbsp;object<br>
&nbsp;<br>
Return&nbsp;a&nbsp;zip&nbsp;object&nbsp;whose&nbsp;.<a href="#izip-__next__">__next__</a>()&nbsp;method&nbsp;returns&nbsp;a&nbsp;tuple&nbsp;where<br>
the&nbsp;i-th&nbsp;element&nbsp;comes&nbsp;from&nbsp;the&nbsp;i-th&nbsp;iterable&nbsp;argument.&nbsp;&nbsp;The&nbsp;.<a href="#izip-__next__">__next__</a>()<br>
method&nbsp;continues&nbsp;until&nbsp;the&nbsp;shortest&nbsp;iterable&nbsp;in&nbsp;the&nbsp;argument&nbsp;sequence<br>
is&nbsp;exhausted&nbsp;and&nbsp;then&nbsp;it&nbsp;raises&nbsp;StopIteration.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="zip-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="zip-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="zip-__next__"><strong>__next__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;next(self).</tt></dd></dl>

<dl><dt><a name="zip-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Return&nbsp;state&nbsp;information&nbsp;for&nbsp;pickling.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="zip-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;object.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

</td></tr></table> <dl><dt><a name="-lineout"><strong>lineout</strong></a>(x)</dt></dl>
 <dl><dt><a name="-lstrip"><strong>lstrip</strong></a>(iterable, chars=None)</dt></dl>
 <dl><dt><a name="-lzapply"><strong>lzapply</strong></a>(datastream, src_field, dst_field, func, eval_strategy=None)</dt><dd><tt>Lazily&nbsp;applies&nbsp;a&nbsp;function&nbsp;to&nbsp;the&nbsp;specified&nbsp;field&nbsp;of&nbsp;the&nbsp;stream&nbsp;and&nbsp;stores&nbsp;the&nbsp;result&nbsp;in&nbsp;the&nbsp;specified&nbsp;field.<br>
You&nbsp;need&nbsp;to&nbsp;make&nbsp;sure&nbsp;that&nbsp;`lzapply`&nbsp;does&nbsp;not&nbsp;create&nbsp;endless&nbsp;recursive&nbsp;loop&nbsp;-&nbsp;you&nbsp;should&nbsp;not&nbsp;use&nbsp;the&nbsp;same<br>
`src_field`&nbsp;and&nbsp;`dst_field`,&nbsp;and&nbsp;avoid&nbsp;situations&nbsp;when&nbsp;x['f1']&nbsp;lazily&nbsp;depends&nbsp;on&nbsp;x['f2'],&nbsp;while&nbsp;x['f2']&nbsp;lazily<br>
depends&nbsp;on&nbsp;x['f1'].</tt></dd></dl>
 <dl><dt><a name="-make_train_test_split"><strong>make_train_test_split</strong></a>(datastream)</dt><dd><tt>Returns&nbsp;a&nbsp;tuple&nbsp;of&nbsp;streams&nbsp;with&nbsp;train&nbsp;and&nbsp;test&nbsp;dataset.&nbsp;It&nbsp;can&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;following&nbsp;manner:<br>
`train,&nbsp;test&nbsp;=&nbsp;<a href="#-get_datastream">get_datastream</a>(..)&nbsp;|&nbsp;...&nbsp;|&nbsp;make_train_test_split()`<br>
**Important**:&nbsp;this&nbsp;causes&nbsp;the&nbsp;whole&nbsp;dataset&nbsp;to&nbsp;be&nbsp;loaded&nbsp;into&nbsp;memory.&nbsp;If&nbsp;objects&nbsp;are&nbsp;large,&nbsp;you&nbsp;are&nbsp;encouraged<br>
to&nbsp;use&nbsp;lazy&nbsp;field&nbsp;evaluation,&nbsp;or&nbsp;to&nbsp;handle&nbsp;it&nbsp;using&nbsp;the&nbsp;following&nbsp;way:<br>
```<br>
train&nbsp;=&nbsp;<a href="#-get_datastream">get_datastream</a>('...')&nbsp;|&nbsp;...&nbsp;|&nbsp;filter_split(<a href="#SplitType">SplitType</a>.Train)<br>
test&nbsp;=&nbsp;<a href="#-get_datastream">get_datastream</a>('...')&nbsp;|&nbsp;...&nbsp;|&nbsp;filter_split(<a href="#SplitType">SplitType</a>.Test)<br>
```<br>
:param&nbsp;datastream:&nbsp;Input&nbsp;datastream<br>
:return:&nbsp;Tuple&nbsp;of&nbsp;the&nbsp;form&nbsp;`(train_stream,test_stream)`</tt></dd></dl>
 <dl><dt><a name="-make_train_validation_test_split"><strong>make_train_validation_test_split</strong></a>(datastream)</dt><dd><tt>Returns&nbsp;a&nbsp;tuple&nbsp;of&nbsp;streams&nbsp;with&nbsp;train,&nbsp;validation&nbsp;and&nbsp;test&nbsp;dataset.&nbsp;See&nbsp;`make_train_test_split`&nbsp;documentation&nbsp;for<br>
limitations&nbsp;and&nbsp;usage&nbsp;suggestions.<br>
:param&nbsp;datastream:&nbsp;Input&nbsp;datastream<br>
:return:&nbsp;Tuple&nbsp;of&nbsp;the&nbsp;form&nbsp;`(train_stream,validation_stream,test_stream)`</tt></dd></dl>
 <dl><dt><a name="-max"><strong>max</strong></a>(iterable, **kwargs)</dt></dl>
 <dl><dt><a name="-min"><strong>min</strong></a>(iterable, **kwargs)</dt></dl>
 <dl><dt><a name="-netcat"><strong>netcat</strong></a>(to_send, host, port)</dt></dl>
 <dl><dt><a name="-netwrite"><strong>netwrite</strong></a>(to_send, host, port)</dt></dl>
 <dl><dt><a name="-normalize_npy_value"><strong>normalize_npy_value</strong></a>(seq, field_name, interval=(0, 1))</dt><dd><tt>Normalize&nbsp;values&nbsp;of&nbsp;the&nbsp;field&nbsp;specified&nbsp;by&nbsp;`field_name`&nbsp;in&nbsp;the&nbsp;given&nbsp;`interval`<br>
Normalization&nbsp;is&nbsp;applied&nbsp;invividually&nbsp;to&nbsp;each&nbsp;sequence&nbsp;element<br>
:param&nbsp;seq:&nbsp;Input&nbsp;datastream<br>
:param&nbsp;field_name:&nbsp;Field&nbsp;name<br>
:param&nbsp;interval:&nbsp;Interval&nbsp;(default&nbsp;to&nbsp;(0,1))<br>
:return:&nbsp;Datastream&nbsp;with&nbsp;a&nbsp;field&nbsp;normalized</tt></dd></dl>
 <dl><dt><a name="-passed"><strong>passed</strong></a>(x)</dt></dl>
 <dl><dt><a name="-pbatch"><strong>pbatch</strong></a>(l, n=10)</dt><dd><tt>Split&nbsp;input&nbsp;sequence&nbsp;into&nbsp;batches&nbsp;of&nbsp;`n`&nbsp;elements.<br>
:param&nbsp;l:&nbsp;Input&nbsp;sequence<br>
:param&nbsp;n:&nbsp;Length&nbsp;of&nbsp;output&nbsp;batches&nbsp;(lists)<br>
:return:&nbsp;Sequence&nbsp;of&nbsp;lists&nbsp;of&nbsp;`n`&nbsp;elements</tt></dd></dl>
 <dl><dt><a name="-pconcat"><strong>pconcat</strong></a>(l)</dt></dl>
 <dl><dt><a name="-pcycle"><strong>pcycle</strong></a>(l)</dt><dd><tt>Infinitely&nbsp;cycle&nbsp;the&nbsp;input&nbsp;sequence<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:return:&nbsp;infinite&nbsp;datastream</tt></dd></dl>
 <dl><dt><a name="-permutations"><strong>permutations</strong></a>(iterable, r=None)</dt></dl>
 <dl><dt><a name="-pexec"><strong>pexec</strong></a>(l, func=None, convert_to_list=False)</dt><dd><tt>Execute&nbsp;function&nbsp;func,&nbsp;passing&nbsp;the&nbsp;pipe&nbsp;sequence&nbsp;as&nbsp;an&nbsp;argument<br>
:param&nbsp;func:&nbsp;Function&nbsp;to&nbsp;execute,&nbsp;must&nbsp;accept&nbsp;1&nbsp;iterator&nbsp;as&nbsp;parameter.<br>
:param&nbsp;convert_to_list:&nbsp;Convert&nbsp;pipe&nbsp;to&nbsp;list&nbsp;before&nbsp;passing&nbsp;it&nbsp;to&nbsp;function.&nbsp;If&nbsp;`func`&nbsp;is&nbsp;`None`,&nbsp;iterator&nbsp;is&nbsp;converted&nbsp;to&nbsp;list&nbsp;anyway.<br>
:return:&nbsp;result&nbsp;of&nbsp;func</tt></dd></dl>
 <dl><dt><a name="-pforeach"><strong>pforeach</strong></a>(l, func)</dt><dd><tt>Execute&nbsp;given&nbsp;function&nbsp;on&nbsp;each&nbsp;element&nbsp;in&nbsp;the&nbsp;pipe<br>
:param&nbsp;l:&nbsp;datastream<br>
:param&nbsp;func:&nbsp;function&nbsp;to&nbsp;be&nbsp;called&nbsp;on&nbsp;each&nbsp;element</tt></dd></dl>
 <dl><dt><a name="-pprint"><strong>pprint</strong></a>(l)</dt><dd><tt>Print&nbsp;the&nbsp;values&nbsp;of&nbsp;a&nbsp;finite&nbsp;pipe&nbsp;generator&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;copy&nbsp;of&nbsp;it.&nbsp;It&nbsp;has&nbsp;to&nbsp;convert&nbsp;generator&nbsp;into&nbsp;in-memory<br>
list,&nbsp;so&nbsp;better&nbsp;not&nbsp;to&nbsp;use&nbsp;it&nbsp;with&nbsp;big&nbsp;data.&nbsp;Use&nbsp;`seq&nbsp;|&nbsp;tee&nbsp;...`&nbsp;instead.<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:return:&nbsp;the&nbsp;same&nbsp;generator</tt></dd></dl>
 <dl><dt><a name="-psave"><strong>psave</strong></a>(datastream, filename)</dt><dd><tt>Save&nbsp;whole&nbsp;datastream&nbsp;into&nbsp;a&nbsp;file&nbsp;for&nbsp;later&nbsp;use<br>
:param&nbsp;datastream:&nbsp;Datastream<br>
:param&nbsp;filename:&nbsp;Filename</tt></dd></dl>
 <dl><dt><a name="-pshuffle"><strong>pshuffle</strong></a>(l)</dt><dd><tt>Shuffle&nbsp;a&nbsp;given&nbsp;pipe.<br>
In&nbsp;the&nbsp;current&nbsp;implementation,&nbsp;it&nbsp;has&nbsp;to&nbsp;store&nbsp;the&nbsp;whole&nbsp;datastream&nbsp;into&nbsp;memory&nbsp;as&nbsp;a&nbsp;list,&nbsp;in&nbsp;order&nbsp;to&nbsp;perform&nbsp;shuffle.<br>
Please&nbsp;not,&nbsp;that&nbsp;the&nbsp;idiom&nbsp;[1,2,3]&nbsp;|&nbsp;pshuffle()&nbsp;|&nbsp;pcycle()&nbsp;will&nbsp;return&nbsp;the&nbsp;same&nbsp;order&nbsp;of&nbsp;the&nbsp;shuffled&nbsp;sequence&nbsp;(eg.&nbsp;something<br>
like&nbsp;[2,1,3,2,1,3,...]),&nbsp;if&nbsp;you&nbsp;want&nbsp;proper&nbsp;infinite&nbsp;shuffle&nbsp;use&nbsp;`infshuffle()`&nbsp;instead.<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:return:&nbsp;list&nbsp;of&nbsp;elements&nbsp;of&nbsp;the&nbsp;datastream&nbsp;in&nbsp;a&nbsp;shuffled&nbsp;order</tt></dd></dl>
 <dl><dt><a name="-puniq"><strong>puniq</strong></a>(l)</dt></dl>
 <dl><dt><a name="-reverse"><strong>reverse</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-rstrip"><strong>rstrip</strong></a>(iterable, chars=None)</dt></dl>
 <dl><dt><a name="-run_with"><strong>run_with</strong></a>(iterable, func)</dt></dl>
 <dl><dt><a name="-sample_classes"><strong>sample_classes</strong></a>(datastream, class_field_name, n=10, classes=None)</dt><dd><tt>Create&nbsp;a&nbsp;datastream&nbsp;containing&nbsp;at&nbsp;most&nbsp;`n`&nbsp;samples&nbsp;from&nbsp;each&nbsp;of&nbsp;the&nbsp;classes&nbsp;defined&nbsp;by&nbsp;`class_field_name`<br>
**Important**&nbsp;If&nbsp;`classes`&nbsp;is&nbsp;`None`,&nbsp;function&nbsp;determines&nbsp;classes&nbsp;on&nbsp;the&nbsp;fly,&nbsp;in&nbsp;which&nbsp;case&nbsp;it&nbsp;is&nbsp;possible&nbsp;that&nbsp;it&nbsp;will&nbsp;terminate&nbsp;early&nbsp;without<br>
giving&nbsp;elements&nbsp;of&nbsp;all&nbsp;classes.<br>
:param&nbsp;datastream:&nbsp;input&nbsp;stream<br>
:param&nbsp;class_field_name:&nbsp;name&nbsp;of&nbsp;the&nbsp;field&nbsp;in&nbsp;the&nbsp;stream&nbsp;speficying&nbsp;the&nbsp;class<br>
:param&nbsp;n:&nbsp;number&nbsp;of&nbsp;elements&nbsp;of&nbsp;each&nbsp;class&nbsp;to&nbsp;take<br>
:param&nbsp;classes:&nbsp;classes&nbsp;descriptor,&nbsp;either&nbsp;dictionary&nbsp;or&nbsp;list<br>
:return:&nbsp;resulting&nbsp;stream</tt></dd></dl>
 <dl><dt><a name="-sapply"><strong>sapply</strong></a>(datastream, field, func)</dt><dd><tt>Self-apply<br>
Applies&nbsp;a&nbsp;function&nbsp;to&nbsp;the&nbsp;specified&nbsp;field&nbsp;of&nbsp;the&nbsp;stream&nbsp;and&nbsp;stores&nbsp;the&nbsp;result&nbsp;in&nbsp;the&nbsp;same&nbsp;field.&nbsp;Sample&nbsp;usage:<br>
`[1,2,3]&nbsp;|&nbsp;as_field('x')&nbsp;|&nbsp;sapply('x',lambda&nbsp;x:&nbsp;x*x)&nbsp;|&nbsp;select_field('x')&nbsp;|&nbsp;as_list`</tt></dd></dl>
 <dl><dt><a name="-scan"><strong>scan</strong></a>(l, field_name, new_field_name, func, init_state)</dt><dd><tt>Perform&nbsp;scan&nbsp;(cumulitive&nbsp;sum)&nbsp;of&nbsp;the&nbsp;datastream,&nbsp;using&nbsp;given&nbsp;function&nbsp;`func`&nbsp;with&nbsp;initial&nbsp;state&nbsp;`init_state`.<br>
Results&nbsp;are&nbsp;places&nbsp;into&nbsp;`new_field_name`&nbsp;field.<br>
:param&nbsp;l:&nbsp;datastream<br>
:param&nbsp;field_name:&nbsp;field&nbsp;name&nbsp;(or&nbsp;list&nbsp;of&nbsp;names)&nbsp;to&nbsp;use<br>
:param&nbsp;new_field_name:&nbsp;field&nbsp;name&nbsp;to&nbsp;use&nbsp;for&nbsp;storing&nbsp;results<br>
:param&nbsp;func:&nbsp;fold&nbsp;function&nbsp;that&nbsp;takes&nbsp;field(s)&nbsp;value&nbsp;and&nbsp;state&nbsp;and&nbsp;returns&nbsp;state.&nbsp;If&nbsp;field_name&nbsp;is&nbsp;None,&nbsp;func<br>
accepts&nbsp;the&nbsp;whole&nbsp;`mdict`&nbsp;as&nbsp;first&nbsp;parameter<br>
:param&nbsp;init_state:&nbsp;initial&nbsp;state<br>
:return:&nbsp;final&nbsp;state&nbsp;of&nbsp;the&nbsp;fold</tt></dd></dl>
 <dl><dt><a name="-select"><strong>select</strong></a>(iterable, selector)</dt></dl>
 <dl><dt><a name="-select_field"><strong>select_field</strong></a>(datastream, field_name)</dt><dd><tt>Extract&nbsp;one/several&nbsp;fields&nbsp;from&nbsp;datastream,&nbsp;returning&nbsp;a&nbsp;stream&nbsp;of&nbsp;objects&nbsp;of&nbsp;corresponding&nbsp;type&nbsp;(not&nbsp;`mdict`).<br>
If&nbsp;several&nbsp;fields&nbsp;are&nbsp;given,&nbsp;return&nbsp;a&nbsp;list/tuple.</tt></dd></dl>
 <dl><dt><a name="-select_fields"><strong>select_fields</strong></a>(datastream, field_names)</dt><dd><tt>Select&nbsp;multiple&nbsp;fields&nbsp;from&nbsp;datastream,&nbsp;returning&nbsp;a&nbsp;*new*&nbsp;stream&nbsp;of&nbsp;*mdicts*&nbsp;with&nbsp;the&nbsp;requested&nbsp;fields&nbsp;copied.<br>
Because&nbsp;field&nbsp;immutability&nbsp;is&nbsp;encouraged,&nbsp;the&nbsp;best&nbsp;way&nbsp;to&nbsp;get&nbsp;rid&nbsp;of&nbsp;some&nbsp;fields&nbsp;and&nbsp;free&nbsp;up&nbsp;memory<br>
is&nbsp;to&nbsp;select&nbsp;out&nbsp;a&nbsp;new&nbsp;data&nbsp;structure&nbsp;with&nbsp;the&nbsp;ones&nbsp;you&nbsp;want&nbsp;copied&nbsp;over.</tt></dd></dl>
 <dl><dt><a name="-set_eval_strategy"><strong>set_eval_strategy</strong></a>(datastream, field_name, evs)</dt><dd><tt>Set&nbsp;evaluation&nbsp;strategy&nbsp;of&nbsp;a&nbsp;speficied&nbsp;field<br>
:param&nbsp;datastream:&nbsp;Datastream<br>
:param&nbsp;field_name:&nbsp;Name&nbsp;of&nbsp;field&nbsp;or&nbsp;fields&nbsp;(str&nbsp;or&nbsp;list)<br>
:param&nbsp;evs:&nbsp;Desired&nbsp;evaluation&nbsp;strategy<br>
:return:&nbsp;Datastream</tt></dd></dl>
 <dl><dt><a name="-silly_progress"><strong>silly_progress</strong></a>(seq, n=None, elements=None, symbol='.', width=40)</dt><dd><tt>Print&nbsp;dots&nbsp;to&nbsp;indicate&nbsp;that&nbsp;something&nbsp;good&nbsp;is&nbsp;happening.&nbsp;A&nbsp;dot&nbsp;is&nbsp;printed&nbsp;every&nbsp;`n`&nbsp;items.<br>
:param&nbsp;seq:&nbsp;original&nbsp;sequence<br>
:param&nbsp;n:&nbsp;number&nbsp;of&nbsp;items&nbsp;to&nbsp;process&nbsp;between&nbsp;printing&nbsp;a&nbsp;dot<br>
:param&nbsp;symbol:&nbsp;symbol&nbsp;to&nbsp;print<br>
:return:&nbsp;original&nbsp;sequence</tt></dd></dl>
 <dl><dt><a name="-skip"><strong>skip</strong></a>(iterable, qte)</dt><dd><tt>Skip&nbsp;qte&nbsp;elements&nbsp;in&nbsp;the&nbsp;given&nbsp;iterable,&nbsp;then&nbsp;yield&nbsp;others.</tt></dd></dl>
 <dl><dt><a name="-skip_while"><strong>skip_while</strong></a>(iterable, predicate)</dt></dl>
 <dl><dt><a name="-sliding_window_npy"><strong>sliding_window_npy</strong></a>(seq, field_names, size, cache=10)</dt><dd><tt>Create&nbsp;a&nbsp;stream&nbsp;of&nbsp;sliding&nbsp;windows&nbsp;from&nbsp;a&nbsp;given&nbsp;stream.<br>
:param&nbsp;seq:&nbsp;Input&nbsp;sequence<br>
:param&nbsp;field_names:&nbsp;Field&nbsp;names&nbsp;to&nbsp;accumulate<br>
:param&nbsp;size:&nbsp;Size&nbsp;of&nbsp;sliding&nbsp;window<br>
:param&nbsp;cache:&nbsp;Size&nbsp;of&nbsp;the&nbsp;caching&nbsp;array,&nbsp;in&nbsp;a&nbsp;number&nbsp;of&nbsp;`size`-chunks.<br>
:return:&nbsp;mPyPl&nbsp;sequence&nbsp;containing&nbsp;numpy&nbsp;arrays&nbsp;for&nbsp;specified&nbsp;fields</tt></dd></dl>
 <dl><dt><a name="-sort"><strong>sort</strong></a>(iterable, **kwargs)</dt></dl>
 <dl><dt><a name="-stdout"><strong>stdout</strong></a>(x)</dt></dl>
 <dl><dt><a name="-stratify_sample"><strong>stratify_sample</strong></a>(seq, n=None, shuffle=False, field_name='class_id')</dt><dd><tt>Returns&nbsp;stratified&nbsp;samples&nbsp;of&nbsp;size&nbsp;`n`&nbsp;from&nbsp;each&nbsp;class&nbsp;(given&nbsp;dy&nbsp;`field_name`)&nbsp;in&nbsp;round&nbsp;robin&nbsp;manner.<br>
NB:&nbsp;This&nbsp;operation&nbsp;is&nbsp;cachy&nbsp;(caches&nbsp;all&nbsp;data&nbsp;in&nbsp;memory)<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:param&nbsp;n:&nbsp;number&nbsp;of&nbsp;samples&nbsp;or&nbsp;`None`&nbsp;(in&nbsp;which&nbsp;case&nbsp;the&nbsp;min&nbsp;number&nbsp;of&nbsp;elements&nbsp;is&nbsp;used)<br>
:param&nbsp;shuffle:&nbsp;perform&nbsp;random&nbsp;shuffling&nbsp;of&nbsp;samples<br>
:param&nbsp;field_name:&nbsp;name&nbsp;of&nbsp;field&nbsp;that&nbsp;specifies&nbsp;classes.&nbsp;`class_no`&nbsp;by&nbsp;default.<br>
:return:&nbsp;result&nbsp;sequence</tt></dd></dl>
 <dl><dt><a name="-stratify_sample_tt"><strong>stratify_sample_tt</strong></a>(seq, n_samples=None, shuffle=False, class_field_name='class_id', split_field_name='split')</dt><dd><tt>Returns&nbsp;stratified&nbsp;training,&nbsp;test&nbsp;and&nbsp;validation&nbsp;samples&nbsp;of&nbsp;size&nbsp;`n_sample`&nbsp;from&nbsp;each&nbsp;class<br>
(given&nbsp;dy&nbsp;`class_field_name`)&nbsp;in&nbsp;round&nbsp;robin&nbsp;manner.<br>
`n_samples`&nbsp;is&nbsp;a&nbsp;dict&nbsp;specifying&nbsp;number&nbsp;of&nbsp;samples&nbsp;for&nbsp;each&nbsp;split&nbsp;type&nbsp;(or&nbsp;None).<br>
NB:&nbsp;This&nbsp;operation&nbsp;is&nbsp;cachy&nbsp;(caches&nbsp;all&nbsp;data&nbsp;in&nbsp;memory)<br>
:param&nbsp;l:&nbsp;input&nbsp;pipe&nbsp;generator<br>
:param&nbsp;n_samples:&nbsp;dict&nbsp;specifying&nbsp;number&nbsp;of&nbsp;samples&nbsp;for&nbsp;each&nbsp;split&nbsp;type&nbsp;or&nbsp;`None`&nbsp;(in&nbsp;which&nbsp;case&nbsp;the&nbsp;min&nbsp;number&nbsp;of&nbsp;elements&nbsp;is&nbsp;used)<br>
:param&nbsp;shuffle:&nbsp;perform&nbsp;random&nbsp;shuffling&nbsp;of&nbsp;samples<br>
:param&nbsp;class_field_name:&nbsp;name&nbsp;of&nbsp;field&nbsp;that&nbsp;specifies&nbsp;classes.&nbsp;`class_id`&nbsp;by&nbsp;default.<br>
:param&nbsp;split_field_name:&nbsp;name&nbsp;of&nbsp;field&nbsp;that&nbsp;specifies&nbsp;split.&nbsp;`split`&nbsp;by&nbsp;default.<br>
:return:&nbsp;result&nbsp;sequence</tt></dd></dl>
 <dl><dt><a name="-strip"><strong>strip</strong></a>(iterable, chars=None)</dt></dl>
 <dl><dt><a name="-summarize"><strong>summarize</strong></a>(seq, field_name, func=None, msg=None)</dt><dd><tt>Compute&nbsp;a&nbsp;summary&nbsp;of&nbsp;a&nbsp;given&nbsp;field&nbsp;(eg.&nbsp;count&nbsp;of&nbsp;different&nbsp;values).&nbsp;Resulting&nbsp;dictionary&nbsp;is&nbsp;either&nbsp;passed&nbsp;to&nbsp;`func`,<br>
or&nbsp;printed&nbsp;on&nbsp;screen&nbsp;(if&nbsp;`func&nbsp;is&nbsp;None`).<br>
:param&nbsp;seq:&nbsp;Datastream<br>
:param&nbsp;field_name:&nbsp;Field&nbsp;name&nbsp;to&nbsp;summarize<br>
:param&nbsp;func:&nbsp;Function&nbsp;to&nbsp;call&nbsp;after&nbsp;summary&nbsp;is&nbsp;obtained&nbsp;(which&nbsp;is&nbsp;after&nbsp;all&nbsp;stream&nbsp;processing).&nbsp;If&nbsp;`None`,&nbsp;summary&nbsp;is&nbsp;printed&nbsp;on&nbsp;screen.<br>
:param&nbsp;msg:&nbsp;Optional&nbsp;message&nbsp;to&nbsp;print&nbsp;before&nbsp;summary<br>
:return:&nbsp;Original&nbsp;stream</tt></dd></dl>
 <dl><dt><a name="-summary"><strong>summary</strong></a>(seq, class_field_name='class_name', split_field_name='split')</dt><dd><tt>Print&nbsp;a&nbsp;summary&nbsp;of&nbsp;a&nbsp;data&nbsp;stream<br>
:param&nbsp;seq:&nbsp;Datastream<br>
:param&nbsp;class_field_name:&nbsp;Field&nbsp;name&nbsp;to&nbsp;differentiate&nbsp;between&nbsp;classes<br>
:param&nbsp;split_field_name:&nbsp;Field&nbsp;name&nbsp;to&nbsp;indicate&nbsp;train/test&nbsp;split<br>
:return:&nbsp;Original&nbsp;stream</tt></dd></dl>
 <dl><dt><a name="-t"><strong>t</strong></a>(iterable, y)</dt></dl>
 <dl><dt><a name="-tail"><strong>tail</strong></a>(iterable, qte)</dt><dd><tt>Yield&nbsp;qte&nbsp;of&nbsp;elements&nbsp;in&nbsp;the&nbsp;given&nbsp;iterable.</tt></dd></dl>
 <dl><dt><a name="-take"><strong>take</strong></a>(iterable, qte)</dt><dd><tt>Yield&nbsp;qte&nbsp;of&nbsp;elements&nbsp;in&nbsp;the&nbsp;given&nbsp;iterable.</tt></dd></dl>
 <dl><dt><a name="-take_while"><strong>take_while</strong></a>(iterable, predicate)</dt></dl>
 <dl><dt><a name="-tee"><strong>tee</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-to_type"><strong>to_type</strong></a>(x, t)</dt></dl>
 <dl><dt><a name="-transpose"><strong>transpose</strong></a>(iterable)</dt></dl>
 <dl><dt><a name="-traverse"><strong>traverse</strong></a>(args)</dt></dl>
 <dl><dt><a name="-unfold"><strong>unfold</strong></a>(l, field_name, func, init_state)</dt><dd><tt>Add&nbsp;extra&nbsp;field&nbsp;to&nbsp;the&nbsp;datastream,&nbsp;which&nbsp;is&nbsp;obtained&nbsp;by&nbsp;applying&nbsp;state&nbsp;transformation&nbsp;function&nbsp;`func`&nbsp;to<br>
initial&nbsp;state&nbsp;`init_state`<br>
:param&nbsp;l:&nbsp;datastream<br>
:param&nbsp;func:&nbsp;state&nbsp;transformation&nbsp;function<br>
:param&nbsp;init_state:&nbsp;initial&nbsp;state<br>
:return:&nbsp;datastream</tt></dd></dl>
 <dl><dt><a name="-uniq"><strong>uniq</strong></a>(iterable)</dt><dd><tt>Deduplicate&nbsp;consecutive&nbsp;duplicate&nbsp;values.</tt></dd></dl>
 <dl><dt><a name="-unroll"><strong>unroll</strong></a>(datastream, field)</dt><dd><tt>Field&nbsp;`field`&nbsp;is&nbsp;assumed&nbsp;to&nbsp;be&nbsp;a&nbsp;sequence.&nbsp;This&nbsp;function&nbsp;unrolls&nbsp;the&nbsp;sequence,&nbsp;i.e.&nbsp;replacing&nbsp;the&nbsp;sequence&nbsp;field<br>
with&nbsp;the&nbsp;actual&nbsp;values&nbsp;inside&nbsp;the&nbsp;sequence.&nbsp;All&nbsp;other&nbsp;field&nbsp;values&nbsp;are&nbsp;duplicated.<br>
:param&nbsp;datasteam:&nbsp;Data&nbsp;stream<br>
:param&nbsp;field:&nbsp;Field&nbsp;name&nbsp;or&nbsp;list&nbsp;of&nbsp;field&nbsp;names.&nbsp;If&nbsp;several&nbsp;fields&nbsp;are&nbsp;listed,&nbsp;corresponding&nbsp;sequences&nbsp;should&nbsp;preferably&nbsp;be&nbsp;of&nbsp;the&nbsp;same&nbsp;size.</tt></dd></dl>
 <dl><dt><a name="-where"><strong>where</strong></a>(iterable, predicate)</dt></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>altsep</strong> = '/'<br>
<strong>curdir</strong> = '.'<br>
<strong>defpath</strong> = r'.;C:\bin'<br>
<strong>devnull</strong> = 'nul'<br>
<strong>extsep</strong> = '.'<br>
<strong>pardir</strong> = '..'<br>
<strong>pathsep</strong> = ';'<br>
<strong>sep</strong> = r'\'<br>
<strong>supports_unicode_filenames</strong> = True</td></tr></table>
</body></html>